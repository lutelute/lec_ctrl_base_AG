<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>複素平面とラプラス変換の可視化</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .pane {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            flex: 1 1 400px;
        }

        canvas {
            border: 1px solid #ddd;
            width: 100%;
            height: 350px;
            background-color: #fff;
            cursor: crosshair;
        }

        .info {
            margin-top: 10px;
            font-family: monospace;
            font-size: 1.1em;
            color: #007bff;
        }

        .control-panel {
            margin-top: 20px;
            padding: 10px;
            background: #eee;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <h1>第2章: 複素平面と時間応答 ($s$平面)</h1>
    <p>複素平面上の点 $s = \sigma + j\omega$ (極) の位置が、時間領域の挙動 $e^{st}$ にどのように対応するかを確認しましょう。<br>
        左側の複素平面上でマウスをクリック・ドラッグして $s$ の位置を変えてみてください。</p>

    <div class="container">
        <!-- Complex Plane -->
        <div class="pane">
            <h3>1. s-平面 (複素平面)</h3>
            <canvas id="sPlaneCanvas" width="400" height="400"></canvas>
            <div class="info" id="sVal">s = -1.0 + j0.0</div>
            <p style="font-size:0.9em; color:#666;">
                横軸: 実部 $\sigma$ (収束・発散)<br>
                縦軸: 虚部 $\omega$ (振動周波数)
            </p>
        </div>

        <!-- Time Domain -->
        <div class="pane">
            <h3>2. 時間応答 (インパルス応答)</h3>
            <canvas id="timeDomainCanvas" width="400" height="400"></canvas>
            <div class="info" id="funcExpr">f(t) = e^{-1.0t}</div>
            <p style="font-size:0.9em; color:#666;">
                $s = \sigma \pm j\omega$ corresponding to $e^{\sigma t} \cos(\omega t)$
            </p>
        </div>
    </div>

    <script>
        const sCanvas = document.getElementById('sPlaneCanvas');
        const sCtx = sCanvas.getContext('2d');
        const tCanvas = document.getElementById('timeDomainCanvas');
        const tCtx = tCanvas.getContext('2d');
        const sValDiv = document.getElementById('sVal');
        const funcExprDiv = document.getElementById('funcExpr');

        // State
        let s = { x: -1.0, y: 0.0 }; // Real(sigma), Imag(omega)
        const scale = 50; // pixels per unit
        const origin = { x: sCanvas.width / 2, y: sCanvas.height / 2 };
        let isDragging = false;

        function drawSPlane() {
            sCtx.clearRect(0, 0, sCanvas.width, sCanvas.height);

            // Draw Grid
            sCtx.strokeStyle = '#eee';
            sCtx.lineWidth = 1;
            for (let x = 0; x <= sCanvas.width; x += scale) {
                sCtx.beginPath(); sCtx.moveTo(x, 0); sCtx.lineTo(x, sCanvas.height); sCtx.stroke();
            }
            for (let y = 0; y <= sCanvas.height; y += scale) {
                sCtx.beginPath(); sCtx.moveTo(0, y); sCtx.lineTo(sCanvas.width, y); sCtx.stroke();
            }

            // Axes
            sCtx.strokeStyle = '#999';
            sCtx.lineWidth = 2;
            // Real axis
            sCtx.beginPath(); sCtx.moveTo(0, origin.y); sCtx.lineTo(sCanvas.width, origin.y); sCtx.stroke();
            sCtx.fillStyle = '#000'; sCtx.fillText("Re (σ)", sCanvas.width - 40, origin.y - 5);
            // Imag axis
            sCtx.beginPath(); sCtx.moveTo(origin.x, 0); sCtx.lineTo(origin.x, sCanvas.height); sCtx.stroke();
            sCtx.fillText("Im (jω)", origin.x + 5, 15);

            // Draw Point s
            const px = origin.x + s.x * scale;
            const py = origin.y - s.y * scale; // Canvas Y is inverted

            // Conjugate pair if imaginary part exists
            if (Math.abs(s.y) > 0.05) {
                const py_conj = origin.y - (-s.y) * scale;
                sCtx.fillStyle = '#ccc';
                sCtx.beginPath(); sCtx.arc(px, py_conj, 4, 0, Math.PI * 2); sCtx.fill();
                sCtx.fillText("x", px - 3, py_conj + 3);
            }

            // Main Pole
            sCtx.fillStyle = '#d63384';
            sCtx.beginPath(); sCtx.arc(px, py, 6, 0, Math.PI * 2); sCtx.fill();
            sCtx.strokeStyle = '#fff'; sCtx.lineWidth = 2; sCtx.stroke();
            sCtx.font = "bold 14px Arial";
            sCtx.fillStyle = '#d63384';
            sCtx.fillText("×", px - 4, py + 4); // Pole notation is usually 'x'
        }

        function drawTimeDomain() {
            tCtx.clearRect(0, 0, tCanvas.width, tCanvas.height);

            // Grid
            tCtx.strokeStyle = '#f5f5f5';
            tCtx.lineWidth = 1;
            const timeScale = 40; // pixels per second
            const valScale = 50; // pixels per unit value
            const tOrigin = { x: 30, y: tCanvas.height / 2 };

            // Axes
            tCtx.strokeStyle = '#999';
            tCtx.lineWidth = 2;
            // t-axis
            tCtx.beginPath(); tCtx.moveTo(0, tOrigin.y); tCtx.lineTo(tCanvas.width, tOrigin.y); tCtx.stroke();
            tCtx.fillStyle = '#000'; tCtx.fillText("t", tCanvas.width - 20, tOrigin.y - 5);
            // y-axis
            tCtx.beginPath(); tCtx.moveTo(tOrigin.x, 0); tCtx.lineTo(tOrigin.x, tCanvas.height); tCtx.stroke();

            // Plot Loop
            tCtx.beginPath();
            tCtx.strokeStyle = '#007bff';
            tCtx.lineWidth = 2;

            const maxT = (tCanvas.width - tOrigin.x) / timeScale;

            for (let px = 0; px < tCanvas.width - tOrigin.x; px++) {
                const t = px / timeScale; // seconds
                // f(t) = e^(sigma*t) * cos(omega*t) (Simplified impulse response form)
                // We use s.y (omega) magnitude
                const val = Math.exp(s.x * t) * Math.cos(s.y * t);

                const py = tOrigin.y - val * valScale;
                if (px === 0) tCtx.moveTo(tOrigin.x + px, py);
                else tCtx.lineTo(tOrigin.x + px, py);
            }
            tCtx.stroke();

            // Envelope lines for decay/growth
            if (Math.abs(s.y) > 0.1) {
                tCtx.beginPath();
                tCtx.strokeStyle = 'rgba(255,0,0,0.2)';
                tCtx.setLineDash([5, 5]);
                for (let px = 0; px < tCanvas.width - tOrigin.x; px++) {
                    const t = px / timeScale;
                    const val = Math.exp(s.x * t);
                    tCtx.lineTo(tOrigin.x + px, tOrigin.y - val * valScale);
                }
                tCtx.stroke();

                tCtx.beginPath();
                for (let px = 0; px < tCanvas.width - tOrigin.x; px++) {
                    const t = px / timeScale;
                    const val = -Math.exp(s.x * t); // Symmetry
                    tCtx.lineTo(tOrigin.x + px, tOrigin.y - val * valScale);
                }
                tCtx.stroke();
                tCtx.setLineDash([]);
            }
        }

        function updateDisplay() {
            const sig = s.x.toFixed(2);
            const omg = Math.abs(s.y).toFixed(2);
            sValDiv.textContent = `s = ${sig} ± j${omg}`;

            if (Math.abs(s.y) < 0.05) {
                funcExprDiv.innerHTML = `f(t) ∝ e^{${sig}t}`;
            } else {
                funcExprDiv.innerHTML = `f(t) ∝ e^{${sig}t} cos(${omg}t)`;
            }

            drawSPlane();
            drawTimeDomain();
        }

        // Interaction
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left - origin.x) / scale,
                y: -(evt.clientY - rect.top - origin.y) / scale
            };
        }

        sCanvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            const p = getMousePos(sCanvas, e);
            s.x = p.x;
            s.y = p.y;
            updateDisplay();
        });

        sCanvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const p = getMousePos(sCanvas, e);
                s.x = p.x;
                s.y = p.y;
                updateDisplay();
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Initial draw
        updateDisplay();

        // Render math (using KaTeX if available or simple text)
        // Note: For this standalone file we stick to simple HTML/CSS per plan.
    </script>
</body>

</html>