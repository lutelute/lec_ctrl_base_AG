<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ボード線図 作成ツール</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }

        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        canvas {
            border: 1px solid #ddd;
            width: 100%;
            height: 300px;
            margin-bottom: 10px;
            background-color: #fff;
        }

        .controls {
            display: flex;
            gap: 20px;
            background: #eee;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .item-list {
            border: 1px solid #ddd;
            padding: 10px;
            min-height: 50px;
            background: #fff;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .item-tag {
            display: inline-block;
            background: #e2e6ea;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 15px;
            font-size: 0.9em;
        }

        .item-tag span {
            cursor: pointer;
            color: red;
            margin-left: 5px;
            font-weight: bold;
        }

        button {
            padding: 8px 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background-color: #0056b3;
        }

        .add-panel {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="number"] {
            width: 60px;
            padding: 5px;
        }
    </style>
</head>

<body>
    <h1>第13章: インタラクティブ・ボード線図</h1>
    <p>要素を追加して、伝達関数 $G(s)$ のボード線図がどのように変化するか観察しましょう。</p>

    <div class="container">
        <h3>伝達関数の構成要素</h3>
        <div class="controls">
            <div class="add-panel">
                <label>比例ゲイン K: </label>
                <input type="number" id="kInput" value="1" step="0.1" style="width: 50px;">
            </div>
            <div class="add-panel">
                <select id="elemType">
                    <option value="pole1">1次遅れ極 (1/(Ts+1))</option>
                    <option value="zero1">1次進み零点 (Ts+1)</option>
                    <option value="integ">積分 (1/s)</option>
                    <option value="diff">微分 (s)</option>
                    <option value="pole2">2次遅れ極 (wn, zeta)</option>
                </select>
                <!-- Params based on selection -->
                <span id="paramSpan">
                    T = <input type="number" id="param1" value="1.0" step="0.1">
                </span>
                <button onclick="addElem()">追加</button>
            </div>
            <button onclick="clearElems()" style="background-color: #dc3545; margin-left:auto;">全てクリア</button>
        </div>

        <div id="itemList" class="item-list"></div>

        <h3>ゲイン線図 [dB]</h3>
        <canvas id="gainChart" width="900" height="300"></canvas>
        <h3>位相線図 [deg]</h3>
        <canvas id="phaseChart" width="900" height="300"></canvas>
    </div>

    <script>
        const gainCanvas = document.getElementById('gainChart');
        const phaseCanvas = document.getElementById('phaseChart');
        const gCtx = gainCanvas.getContext('2d');
        const pCtx = phaseCanvas.getContext('2d');
        const itemListDiv = document.getElementById('itemList');
        const elemSelect = document.getElementById('elemType');
        const paramSpan = document.getElementById('paramSpan');

        let K = 1.0;
        let elements = [
            // { type: 'pole1', T: 1.0 }, etc
        ];

        // Initial setup
        elements.push({ type: 'pole1', T: 1.0 }); // Start with simplified example

        elemSelect.onchange = () => {
            const val = elemSelect.value;
            if (val === 'pole1' || val === 'zero1') {
                paramSpan.innerHTML = 'T = <input type="number" id="param1" value="1.0" step="0.1">';
            } else if (val === 'integ' || val === 'diff') {
                paramSpan.innerHTML = '';
            } else if (val === 'pole2') {
                paramSpan.innerHTML = 'wn = <input type="number" id="param1" value="10" step="1"> zeta = <input type="number" id="param2" value="0.5" step="0.1">';
            }
        };

        function addElem() {
            const type = elemSelect.value;
            const p1 = document.getElementById('param1') ? parseFloat(document.getElementById('param1').value) : 0;
            const p2 = document.getElementById('param2') ? parseFloat(document.getElementById('param2').value) : 0;

            elements.push({ type, p1, p2 });
            update();
        }

        function removeElem(idx) {
            elements.splice(idx, 1);
            update();
        }

        function clearElems() {
            elements = [];
            update();
        }

        document.getElementById('kInput').addEventListener('input', update);

        function update() {
            K = parseFloat(document.getElementById('kInput').value) || 1.0;
            renderList();
            draw();
        }

        function renderList() {
            itemListDiv.innerHTML = `<strong>G(s) = ${K}</strong> `;
            elements.forEach((el, idx) => {
                const tag = document.createElement('div');
                tag.className = 'item-tag';
                let txt = "";
                if (el.type === 'pole1') txt = `1 / (${el.p1}s + 1)`;
                if (el.type === 'zero1') txt = `(${el.p1}s + 1)`;
                if (el.type === 'integ') txt = `1/s`;
                if (el.type === 'diff') txt = `s`;
                if (el.type === 'pole2') txt = `wn^2 / (s^2 + ...)`; // Shorten

                tag.innerHTML = txt + `<span onclick="removeElem(${idx})">×</span>`;
                itemListDiv.appendChild(tag);
            });
        }

        function calcResponse(w) {
            // Complex math: mag and phase
            // Initialize with Gain K
            let magTotal = Math.abs(K);
            let phTotal = (K >= 0) ? 0 : -180;

            elements.forEach(el => {
                let m = 1, p = 0;
                // jw
                const s_re = 0;
                const s_im = w;

                if (el.type === 'pole1') {
                    // 1 / (j w T + 1)
                    // Mag: 1 / sqrt(1 + (wT)^2)
                    // Ph: -atan(wT)
                    m = 1 / Math.sqrt(1 + (w * el.p1) ** 2);
                    p = -Math.atan(w * el.p1) * 180 / Math.PI;
                } else if (el.type === 'zero1') {
                    m = Math.sqrt(1 + (w * el.p1) ** 2);
                    p = Math.atan(w * el.p1) * 180 / Math.PI;
                } else if (el.type === 'integ') {
                    // 1 / jw = -j / w
                    m = 1 / w;
                    p = -90;
                } else if (el.type === 'diff') {
                    m = w;
                    p = 90;
                } else if (el.type === 'pole2') {
                    // wn^2 / ( (jw)^2 + 2z wn jw + wn^2 )
                    // = wn^2 / ( (wn^2 - w^2) + j(2z wn w) )
                    const wn = el.p1;
                    const z = el.p2;
                    const re = wn * wn - w * w;
                    const im = 2 * z * wn * w;
                    const denomMag = Math.sqrt(re * re + im * im);
                    m = (wn * wn) / denomMag;
                    p = -Math.atan2(im, re) * 180 / Math.PI;
                }

                magTotal *= m;
                phTotal += p;
            });

            // Normalize phase to -360 ~ 0 ? Or just let it accumulate
            // Typical Bode plots show accumulated phase (unwrapped)
            return { mag: 20 * Math.log10(magTotal), ph: phTotal };
        }

        function draw() {
            gCtx.clearRect(0, 0, gainCanvas.width, gainCanvas.height);
            pCtx.clearRect(0, 0, phaseCanvas.width, phaseCanvas.height);

            const wMin = 0.01;
            const wMax = 100;
            const logMin = Math.log10(wMin);
            const logMax = Math.log10(wMax);
            const wScale = gainCanvas.width / (logMax - logMin);

            const steps = 400;
            const data = [];

            for (let i = 0; i <= steps; i++) {
                const logW = logMin + (i / steps) * (logMax - logMin);
                const w = Math.pow(10, logW);
                const res = calcResponse(w);
                data.push({ x: (i / steps) * gainCanvas.width, mag: res.mag, ph: res.ph });
            }

            // Draw Charts (Similar to prev session but cleaner)
            // Gain Chart
            // Auto scale Y ?
            let gMax = -1000, gMin = 1000;
            data.forEach(d => { if (d.mag > gMax) gMax = d.mag; if (d.mag < gMin) gMin = d.mag; });
            if (gMax < 0) gMax = 20;
            if (gMin > 0) gMin = -20;
            const gRange = Math.max(gMax - gMin, 40);
            const gCenter = (gMax + gMin) / 2;

            function gY(val) { return gainCanvas.height / 2 - (val - gCenter) * (gainCanvas.height / gRange); }

            // Grid 0dB
            gCtx.strokeStyle = '#ccc'; gCtx.beginPath(); gCtx.moveTo(0, gY(0)); gCtx.lineTo(gainCanvas.width, gY(0)); gCtx.stroke();
            gCtx.fillStyle = '#666'; gCtx.fillText("0 dB", 5, gY(0) - 5);

            gCtx.beginPath(); gCtx.strokeStyle = 'blue'; gCtx.lineWidth = 2;
            data.forEach((d, i) => { if (i === 0) gCtx.moveTo(d.x, gY(d.mag)); else gCtx.lineTo(d.x, gY(d.mag)); });
            gCtx.stroke();

            // Phase Chart
            // Auto scale ?
            let pMax = -1000, pMin = 1000;
            data.forEach(d => { if (d.ph > pMax) pMax = d.ph; if (d.ph < pMin) pMin = d.ph; });
            const pRange = Math.max(pMax - pMin, 90);
            const pCenter = (pMax + pMin) / 2;

            function pY(val) { return phaseCanvas.height / 2 - (val - pCenter) * (phaseCanvas.height / pRange); }

            // Grid -180, -90, 0
            [-180, -90, 0].forEach(deg => {
                pCtx.strokeStyle = '#ccc'; pCtx.beginPath(); pCtx.moveTo(0, pY(deg)); pCtx.lineTo(phaseCanvas.width, pY(deg)); pCtx.stroke();
                pCtx.fillStyle = '#666'; pCtx.fillText(deg + "°", 5, pY(deg) - 5);
            });

            pCtx.beginPath(); pCtx.strokeStyle = 'red'; pCtx.lineWidth = 2;
            data.forEach((d, i) => { if (i === 0) pCtx.moveTo(d.x, pY(d.ph)); else pCtx.lineTo(d.x, pY(d.ph)); });
            pCtx.stroke();
        }

        elemSelect.onchange(); // trigger init param inputs
        update();
    </script>
</body>

</html>