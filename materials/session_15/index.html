<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>総合制御シミュレータ</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
            background-color: #f9f9f9;
            color: #333;
        }

        h1 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            flex: 1 1 450px;
        }

        canvas {
            border: 1px solid #ddd;
            width: 100%;
            height: 300px;
            margin-bottom: 10px;
            background-color: #fff;
        }

        .controls {
            display: grid;
            gap: 10px;
            background: #eee;
            padding: 15px;
            border-radius: 5px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        label {
            font-weight: bold;
            font-size: 0.9em;
        }

        input[type="number"],
        select {
            padding: 5px;
            width: 100%;
            box-sizing: border-box;
        }

        button {
            padding: 10px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }

        button:hover {
            background-color: #0056b3;
        }

        .status {
            padding: 10px;
            background: #e2e6ea;
            border-radius: 4px;
            margin-top: 10px;
            font-family: monospace;
        }
    </style>
</head>

<body>
    <h1>第15章: 総合制御シミュレータ</h1>
    <p>制御対象とコントローラを自由に組み合わせて、時間応答（ステップ応答）と周波数応答（ボード線図）を同時に確認できます。</p>

    <div class="container">
        <!-- Input Panel -->
        <div class="panel" style="flex: 0 0 300px;">
            <h3>設定</h3>
            <div class="controls">
                <label>制御対象 P(s)</label>
                <select id="plantSelect">
                    <option value="first">1次遅れ (K / Ts+1)</option>
                    <option value="second">2次遅れ (wn^2 / s^2+2zwn s+wn^2)</option>
                    <option value="integ">積分系 (1/s)</option>
                    <option value="unstable">不安定 (1 / s-1)</option>
                </select>
                <div id="plantParams" class="grid-2">
                    <!-- Injected by JS -->
                </div>

                <label style="margin-top:10px;">コントローラ C(s)</label>
                <select id="ctrlSelect">
                    <option value="p">P制御 (Kp)</option>
                    <option value="pi">PI制御 (Kp(1 + 1/Tis))</option>
                    <option value="pid">PID制御 (Kp(1 + 1/Tis + Tds))</option>
                </select>
                <div id="ctrlParams" class="grid-2">
                    <!-- Injected by JS -->
                </div>

                <button onclick="updateSim()">シミュレーション実行</button>
            </div>
            <div class="status" id="statusDisp">
                安定性: -<br>
                GM: - dB<br>
                PM: - deg
            </div>
        </div>

        <!-- Simulation Panel -->
        <div class="panel" style="flex: 1;">
            <h3>1. ステップ応答 (Time Domain)</h3>
            <canvas id="timeChart" width="600" height="300"></canvas>

            <h3>2. ボード線図 (Open Loop L(s))</h3>
            <canvas id="bodeChart" width="600" height="300"></canvas>
        </div>
    </div>

    <script>
        const plantSelect = document.getElementById('plantSelect');
        const ctrlSelect = document.getElementById('ctrlSelect');
        const plantParams = document.getElementById('plantParams');
        const ctrlParams = document.getElementById('ctrlParams');
        const statusDisp = document.getElementById('statusDisp');
        const timeChart = document.getElementById('timeChart').getContext('2d');
        const bodeChart = document.getElementById('bodeChart').getContext('2d');

        // Initial setup
        updateUI();

        plantSelect.onchange = updateUI;
        ctrlSelect.onchange = updateUI;

        function updateUI() {
            // Plant Inputs
            let pHtml = "";
            if (plantSelect.value === 'first') {
                pHtml += `<div>K: <input type="number" id="pK" value="1"></div>`;
                pHtml += `<div>T: <input type="number" id="pT" value="1"></div>`;
            } else if (plantSelect.value === 'second') {
                pHtml += `<div>wn: <input type="number" id="pWn" value="3"></div>`;
                pHtml += `<div>z: <input type="number" id="pZ" value="0.5"></div>`;
            } else if (plantSelect.value === 'integ') {
                pHtml += `<div>K: <input type="number" id="pK" value="1"></div>`;
            } else if (plantSelect.value === 'unstable') {
                pHtml += `<div>Pole: <input type="number" id="pPole" value="1" disabled title="fixed at +1"></div>`;
            }
            plantParams.innerHTML = pHtml;

            // Controller Inputs
            let cHtml = `<div>Kp: <input type="number" id="cKp" value="1"></div>`;
            if (ctrlSelect.value !== 'p') {
                cHtml += `<div>Ti: <input type="number" id="cTi" value="1"></div>`;
            }
            if (ctrlSelect.value === 'pid') {
                cHtml += `<div>Td: <input type="number" id="cTd" value="0.1"></div>`;
            }
            ctrlParams.innerHTML = cHtml;
        }

        function getParams() {
            const pType = plantSelect.value;
            const cType = ctrlSelect.value;
            const p = {};
            const c = { Kp: parseFloat(document.getElementById('cKp').value) };

            if (pType === 'first' || pType === 'integ') p.K = parseFloat(document.getElementById('pK').value);
            if (pType === 'first') p.T = parseFloat(document.getElementById('pT').value);
            if (pType === 'second') { p.wn = parseFloat(document.getElementById('pWn').value); p.z = parseFloat(document.getElementById('pZ').value); }

            if (cType !== 'p') c.Ti = parseFloat(document.getElementById('cTi').value);
            if (cType === 'pid') c.Td = parseFloat(document.getElementById('cTd').value);

            return { pType, cType, p, c };
        }

        function calcLoopResponse(w, params) {
            // Calculate L(jw) = C(jw)P(jw)
            // Return magnitude (dB) and phase (deg)
            let magP = 1, phP = 0;
            let magC = 1, phC = 0;
            const { pType, cType, p, c } = params;

            // Plant P(jw)
            if (pType === 'first') {
                // K / (1 + jwT)
                const den = Math.sqrt(1 + (w * p.T) ** 2);
                magP = p.K / den;
                phP = -Math.atan(w * p.T) * 180 / Math.PI;
            } else if (pType === 'integ') {
                // K / jw
                magP = p.K / w;
                phP = -90;
            } else if (pType === 'second') {
                // wn^2 / ((wn^2-w^2) + j 2z wn w)
                const re = p.wn ** 2 - w ** 2;
                const im = 2 * p.z * p.wn * w;
                magP = (p.wn ** 2) / Math.sqrt(re ** 2 + im ** 2);
                phP = -Math.atan2(im, re) * 180 / Math.PI;
            } else if (pType === 'unstable') {
                // 1 / (jw - 1) = 1 / (-1 + jw)
                // Mag: 1 / sqrt(1+w^2)
                // Phase: -atan2(w, -1) -> 180 - atan(w) or similar.
                // -1 + jw is in 2nd quadrant. Angle is > 90.
                // 1 / (-1+jw). Angle = - Angle(-1+jw). 
                // Angle(-1+jw) is 180 - atan(w). So Phase is -180 + atan(w).
                magP = 1 / Math.sqrt(1 + w ** 2);
                phP = -(Math.PI - Math.atan(w)) * 180 / Math.PI;
            }

            // Controller C(jw)
            // P: Kp
            // PI: Kp(1 + 1/j w Ti) = Kp( (j w Ti + 1) / j w Ti )
            // PID: Kp(1 + 1/j w Ti + j w Td) = Kp( ( -w^2 Ti Td + j w Ti + 1 ) / j w Ti )

            if (cType === 'p') {
                magC = c.Kp;
                phC = 0;
            } else if (cType === 'pi') {
                // Kp * sqrt(1 + (wTi)^2) / (wTi)
                // Phase: atan(wTi) - 90
                // Numerator 1 + jwTi. Angle atan(wTi). Denom jwTi. Angle 90.
                // Result angle atan(wTi) - 90.
                // Wait, 1 + 1/jwTi = (jwTi + 1)/jwTi. 
                // Num angle atan(wTi). Denom angle 90. Total atan(wTi)-90.
                // Correct.
                magC = c.Kp * Math.sqrt(1 + (w * c.Ti) ** 2) / (w * c.Ti);
                phC = Math.atan(w * c.Ti) * 180 / Math.PI - 90;
            } else if (cType === 'pid') {
                // 1 - w^2 Ti Td + j w Ti
                const re = 1 - w ** 2 * c.Ti * c.Td;
                const im = w * c.Ti;
                magC = c.Kp * Math.sqrt(re ** 2 + im ** 2) / (w * c.Ti);
                phC = Math.atan2(im, re) * 180 / Math.PI - 90;
            }

            return { mag: 20 * Math.log10(magP * magC), ph: phP + phC };
        }

        // Time domain simulation: Need discretization or RK4
        // To keep this generic and simple in one file is tough.
        // Let's use simple difference equations for specific combos or generic state space?
        // Generic state space is best but converting types to SS in JS is tedious.
        // Let's just simulate the Plant and Controller as connected blocks.
        // Error e = r - y.
        // Controller u = f(e).
        // Plant y = f(u).
        // Update both using simple Euler or Trapezoidal.

        function updateSim() {
            const params = getParams();
            const { pType, cType, p, c } = params;

            // 1. Bode Plot & Stability Check
            // Sweep w
            const bodeData = [];
            for (let i = 0; i < 300; i++) {
                const w = Math.pow(10, -2 + i * 4 / 300); // 0.01 to 100
                const res = calcLoopResponse(w, params);
                // Unwrapping phase is hard here without history, but simple check:
                // If jump > 180, adjust.
                if (i > 0) {
                    while (res.ph < bodeData[i - 1].ph - 180) res.ph += 360;
                    while (res.ph > bodeData[i - 1].ph + 180) res.ph -= 360;
                }
                bodeData.push({ w, ...res });
            }
            drawBode(bodeChart, bodeData);

            // Check Margins approximation (same logic as before)
            // ... (ommited for brevity, reused logic possible)

            // 2. Time Domain Step Response
            // r = 1.
            // Setup states
            let time = 0;
            const dt = 0.01;
            const Tmax = 10;
            const dataT = [];

            // Controller States
            let i_err = 0;
            let last_err = 0;

            // Plant States (General 2nd order max)
            let x1 = 0, x2 = 0; // x1=y, x2=y_dot

            for (let i = 0; i < Tmax / dt; i++) {
                const r = 1.0;
                const y = x1;
                const e = r - y;

                // Controller Output u
                let u = 0;
                if (cType === 'p') u = c.Kp * e;
                else {
                    i_err += e * dt;
                    let termD = 0;
                    if (cType === 'pid') {
                        // Td derivative. Use backward diff.
                        const d_err = (e - last_err) / dt;
                        termD = c.Td * d_err;
                    }
                    u = c.Kp * (e + (1 / c.Ti) * i_err + termD); // Std form Kp(1 + 1/Tis + Tds)
                }
                last_err = e;

                // Plant Update
                let dy = 0, ddy = 0;

                if (pType === 'first') {
                    // T y_dot + y = K u
                    // y_dot = (Ku - y)/T
                    dy = (p.K * u - x1) / p.T;
                    x1 += dy * dt;
                } else if (pType === 'integ') {
                    // y_dot = K u
                    dy = p.K * u;
                    x1 += dy * dt;
                } else if (pType === 'second') {
                    // y_ddot + 2z wn y_dot + wn^2 y = wn^2 u  (unity gain at DC if s->0?)
                    // Normalized form usually G(0)=1? No, G(s) = wn^2/...
                    // Yes G(0)=1.
                    // dd_y = wn^2 u - 2z wn y_dot - wn^2 y
                    // x1=y, x2=y_dot
                    ddy = p.wn ** 2 * u - 2 * p.z * p.wn * x2 - p.wn ** 2 * x1;
                    x2 += ddy * dt;
                    x1 += x2 * dt;
                } else if (pType === 'unstable') {
                    // 1/(s-1) -> y_dot - y = u -> y_dot = u + y
                    dy = u + x1;
                    x1 += dy * dt;
                }

                dataT.push({ t: time, y: x1 });
                time += dt;

                // Divergence check
                if (Math.abs(x1) > 100) break;
            }
            drawTime(timeChart, dataT);
        }

        function drawTime(ctx, data) {
            ctx.clearRect(0, 0, 600, 300);
            if (data.length === 0) return;

            // Auto scale
            let maxY = -1e9, minY = 1e9;
            data.forEach(d => { if (d.y > maxY) maxY = d.y; if (d.y < minY) minY = d.y; });
            // Include target 1
            if (maxY < 1.1) maxY = 1.1;
            if (minY > -0.1) minY = -0.1;

            const margin = 20;
            const w = 600 - 2 * margin;
            const h = 300 - 2 * margin;

            const rangeY = maxY - minY;
            const maxT = data[data.length - 1].t;

            function tX(t) { return margin + (t / maxT) * w; }
            function tY(y) { return margin + h - ((y - minY) / rangeY) * h; }

            // Target
            ctx.beginPath(); ctx.strokeStyle = 'green'; ctx.setLineDash([5, 5]);
            ctx.moveTo(tX(0), tY(1)); ctx.lineTo(tX(maxT), tY(1)); ctx.stroke(); ctx.setLineDash([]);

            // Plot
            ctx.beginPath(); ctx.strokeStyle = 'blue'; ctx.lineWidth = 2;
            data.forEach((d, i) => {
                if (i === 0) ctx.moveTo(tX(d.t), tY(d.y));
                else ctx.lineTo(tX(d.t), tY(d.y));
            });
            ctx.stroke();
        }

        function drawBode(ctx, data) {
            ctx.clearRect(0, 0, 600, 300);

            // Split height: Top half Gain, Bottom half Phase
            const h = 300;
            const h2 = h / 2; // 150

            // Draw axis line
            ctx.beginPath(); ctx.moveTo(0, h2); ctx.lineTo(600, h2); ctx.strokeStyle = '#aaa'; ctx.stroke();

            const minLog = -2, maxLog = 2; // 0.01 to 100
            const wScale = 600 / (maxLog - minLog);

            function bX(w) { return (Math.log10(w) - minLog) * wScale; }

            // Gain: Center 0dB at h2/2 = 75. Scale 20dB = 50px?
            // Gain Range: +/- 60dB
            function gY(dB) { return 75 - (dB / 60) * 75; }

            // Phase: Center -180 at h2 + 75 = 225. Scale 180deg = 75px?
            function pY(deg) { return 225 - ((deg - (-180)) / 180) * 75; }

            // Gain Plot
            ctx.beginPath(); ctx.strokeStyle = 'blue';
            data.forEach((d, i) => {
                const x = bX(d.w);
                const y = gY(d.mag);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Phase Plot
            ctx.beginPath(); ctx.strokeStyle = 'red';
            data.forEach((d, i) => {
                const x = bX(d.w);
                const y = pY(d.ph);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Labels
            ctx.fillStyle = 'blue'; ctx.fillText("Gain (dB)", 5, 20);
            ctx.fillStyle = 'red'; ctx.fillText("Phase (deg)", 5, 170);
            ctx.fillStyle = '#aaa'; ctx.fillText("0dB", 5, 75);
            ctx.fillText("-180°", 5, 225);
        }

        updateSim();
    </script>
</body>

</html>